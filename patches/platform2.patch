From 625c4231a001d4c710a25a800a45d086ae183801 Mon Sep 17 00:00:00 2001
From: David Drysdale <drysdale@google.com>
Date: Fri, 12 Sep 2014 10:32:19 +0100
Subject: [PATCH] Updates for standalone Linux Chaps build

 - Pass through BASE_VER to preprocessor
 - Turn on exception support, needed for D-Bus C++ library
 - Protect against bad argument to C_GetInfo
 - Downgrade excessive logs
 - Reinstate D-Bus service file org.chromium.Chaps.service
 - DBus::Connection::acquire_name does not exist in the upstream version
   of libdbus-c++, so stick to the original request_name use on Linux
 - Disable :memory: tests if libmemenv not present.
 - Return CKR_BUFFER_TOO_SMALL if a buffer was provided by the user.
 - Ensure PAM module links with libpam.
 - Set SONAME in libchaps.0.so if CHAPS_VERSION_MAJOR specified.
 - Prevent interspersal of incremental and one-shot operations.
---
 chaps/Makefile                   | 24 ++++++++++++++++++++++-
 chaps/chaps.cc                   |  3 ++-
 chaps/chaps_adaptor.cc           |  4 ++++
 chaps/chaps_proxy.cc             |  2 +-
 chaps/isolate_linux.cc           |  2 +-
 chaps/object_store_test.cc       |  2 ++
 chaps/org.chromium.Chaps.service |  4 ++++
 chaps/session_impl.cc            | 42 ++++++++++++++++++++++++++++++++++++++--
 chaps/session_impl.h             |  9 +++++++++
 9 files changed, 86 insertions(+), 6 deletions(-)
 create mode 100644 chaps/org.chromium.Chaps.service

diff --git a/chaps/Makefile b/chaps/Makefile
index ad55a06..2083816 100644
--- a/chaps/Makefile
+++ b/chaps/Makefile
@@ -34,7 +34,7 @@ PC_DEPS = dbus-c++-1 protobuf-lite openssl \
 PC_CFLAGS := $(shell $(PKG_CONFIG) --cflags $(PC_DEPS))
 PC_LIBS := $(shell $(PKG_CONFIG) --libs $(PC_DEPS))
 
-CXXFLAGS += -I$(SRC)/.. -I$(OUT) $(PC_CFLAGS) -DNDEBUG -std=gnu++11
+CXXFLAGS += -I$(SRC)/.. -I$(OUT) $(PC_CFLAGS) -DNDEBUG -std=gnu++11 -fexceptions -DBASE_VER=$(BASE_VER)
 LDLIBS += $(PC_LIBS)
 
 # Test if libmemenv is available, and whether libsnappy is required to
@@ -127,9 +127,13 @@ all: CXX_BINARY(chapsd)
 # Chaps DBus Configuration
 ifeq ($(LINUX_BUILD),1)
 DBUS_POLICY = "context=\"default\""
+DBUS_FLAGS = -DNO_DBUS_ACQUIRE_NAME
 else
 DBUS_POLICY = "group=\"pkcs11\""
+DBUS_FLAGS =
 endif
+CXXFLAGS += $(DBUS_FLAGS)
+
 .PHONY: $(OUT)/org.chromium.Chaps.conf
 $(OUT)/org.chromium.Chaps.conf :
 	sed -e "s/@POLICY_PERMISSIONS@/$(DBUS_POLICY)/" \
@@ -144,6 +148,17 @@ CXX_LIBRARY(libchaps.so): $(libchaps_OBJS)
 clean: CLEAN(libchaps.so)
 all: CXX_LIBRARY(libchaps.so)
 
+ifneq ($(CHAPS_VERSION_MAJOR),)
+ifneq ($(CHAPS_VERSION_MINOR),)
+CHAPS_VERSION=$(CHAPS_VERSION_MAJOR).$(CHAPS_VERSION_MINOR)
+# Also build a version with SONAME set.
+CXX_LIBRARY(libchaps.so.$(CHAPS_VERSION)): $(libchaps_OBJS)
+CXX_LIBRARY(libchaps.so.$(CHAPS_VERSION)): LDFLAGS += -Wl,-soname,libchaps.so.$(CHAPS_VERSION_MAJOR)
+clean: CLEAN(libchaps.so.$(CHAPS_VERSION))
+all: CXX_LIBRARY(libchaps.so.$(CHAPS_VERSION))
+endif
+endif
+
 # Chaps Client CLI App
 chaps_client_OBJS = $(COMMON_OBJS) chaps_client.o chaps_proxy.o \
                     token_manager_client.o isolate_$(PLATFORM).o
@@ -164,6 +179,7 @@ pamchaps_OBJS = $(COMMON_OBJS) chaps_pam_module.o chaps.o chaps_proxy.o \
                 token_file_manager_$(PLATFORM).o isolate_$(PLATFORM).o \
                 platform_globals_$(PLATFORM).o
 CXX_LIBRARY(pam_chaps.so): $(pamchaps_OBJS)
+CXX_LIBRARY(pam_chaps.so): LDLIBS += -lpam
 clean: CLEAN(pam_chaps.so)
 all: CXX_LIBRARY(pam_chaps.so)
 endif
@@ -173,7 +189,13 @@ ifeq ($(LINUX_BUILD), 1)
 install_files: all
 	$(INSTALL) -D $(OUT)/chapsd $(DESTDIR)/usr/sbin/chapsd
 	$(INSTALL) -D $(OUT)/chaps_client $(DESTDIR)/usr/bin/chaps_client
+ifneq ($(CHAPS_VERSION),)
+	$(INSTALL) -D $(OUT)/libchaps.so.$(CHAPS_VERSION) $(DESTDIR)$(LIB_DIR)/libchaps.so.$(CHAPS_VERSION)
+	cd $(DESTDIR)$(LIB_DIR) && ln -s -f libchaps.so.$(CHAPS_VERSION) libchaps.so.$(CHAPS_VERSION_MAJOR)
+	cd $(DESTDIR)$(LIB_DIR) && ln -s -f libchaps.so.$(CHAPS_VERSION_MAJOR) libchaps.so
+else
 	$(INSTALL) -D $(OUT)/libchaps.so $(DESTDIR)$(LIB_DIR)/libchaps.so
+endif
 	$(INSTALL_DATA) -D $(OUT)/org.chromium.Chaps.conf \
 	  $(DESTDIR)/etc/dbus-1/system.d/org.chromium.Chaps.conf
 	$(INSTALL_DATA) -D $(SRC)/org.chromium.Chaps.service \
diff --git a/chaps/chaps.cc b/chaps/chaps.cc
index 077323d..60abdf9 100644
--- a/chaps/chaps.cc
+++ b/chaps/chaps.cc
@@ -76,7 +76,7 @@ static CK_RV HandlePKCS11Output(CK_RV result,
     memcpy(out_buffer, &output.front(), output.size());
   } else {
     *out_buffer_length = static_cast<CK_ULONG>(output_length);
-    if (result == CKR_BUFFER_TOO_SMALL)
+    if (result == CKR_BUFFER_TOO_SMALL && !out_buffer)
       result = CKR_OK;
   }
   return result;
@@ -183,6 +183,7 @@ CK_RV C_GetInfo(CK_INFO_PTR pInfo) {
 
 // PKCS #11 v2.20 section 11.4 page 106.
 CK_RV C_GetFunctionList(CK_FUNCTION_LIST_PTR_PTR ppFunctionList) {
+  LOG_CK_RV_AND_RETURN_IF(!ppFunctionList, CKR_ARGUMENTS_BAD);
   static CK_VERSION version = {2, 20};
   static CK_FUNCTION_LIST functionList = {
     version,
diff --git a/chaps/chaps_adaptor.cc b/chaps/chaps_adaptor.cc
index 3e02d24..7f3eb2b 100644
--- a/chaps/chaps_adaptor.cc
+++ b/chaps/chaps_adaptor.cc
@@ -25,7 +25,11 @@ namespace chaps {
 // Helper used when calling the ObjectAdaptor constructor.
 static DBus::Connection& GetConnection() {
   static DBus::Connection connection = DBus::Connection::SystemBus();
+#ifdef NO_DBUS_ACQUIRE_NAME
+  connection.request_name(kChapsServiceName);
+#else
   CHECK(connection.acquire_name(kChapsServiceName));
+#endif
   return connection;
 }
 
diff --git a/chaps/chaps_proxy.cc b/chaps/chaps_proxy.cc
index 42163a3..f950234 100644
--- a/chaps/chaps_proxy.cc
+++ b/chaps/chaps_proxy.cc
@@ -38,7 +38,7 @@ bool ChapsProxyImpl::Init() {
     if (proxy_.get()) {
       if (!WaitForService())
         return false;
-      LOG(INFO) << "Chaps proxy initialized (" << kChapsServicePath << ").";
+      VLOG(1) << "Chaps proxy initialized (" << kChapsServicePath << ").";
       return true;
     }
   } catch (DBus::Error err) {
diff --git a/chaps/isolate_linux.cc b/chaps/isolate_linux.cc
index 6be57c9..e91b725 100644
--- a/chaps/isolate_linux.cc
+++ b/chaps/isolate_linux.cc
@@ -60,7 +60,7 @@ bool IsolateCredentialManager::GetUserIsolateCredential(
   const FilePath credential_file = FilePath(kIsolateFilePath).Append(user);
   if (!base::PathExists(credential_file) ||
       !base::ReadFileToString(credential_file, &credential_string)) {
-    LOG(INFO) << "Failed to find or read isolate credential for user "
+    VLOG(1) << "Failed to find or read isolate credential for user "
                << user;
     return false;
   }
diff --git a/chaps/object_store_test.cc b/chaps/object_store_test.cc
index 30aafdf..f5d1298 100644
--- a/chaps/object_store_test.cc
+++ b/chaps/object_store_test.cc
@@ -120,6 +120,7 @@ TEST_F(TestObjectStoreEncryption, CBCMode) {
   EXPECT_FALSE(encrypted_block1 == encrypted_block2);
 }
 
+#ifndef NO_MEMENV
 TEST(TestObjectStore, InsertLoad) {
   ObjectStoreImpl store;
   const FilePath::CharType database[] = FILE_PATH_LITERAL(":memory:");
@@ -224,6 +225,7 @@ TEST(TestObjectStore, DeleteAll) {
   EXPECT_TRUE(store.GetInternalBlob(1, &internal));
   EXPECT_EQ("internal", internal);
 }
+#endif
 
 }  // namespace chaps
 
diff --git a/chaps/org.chromium.Chaps.service b/chaps/org.chromium.Chaps.service
new file mode 100644
index 0000000..10cf47e
--- /dev/null
+++ b/chaps/org.chromium.Chaps.service
@@ -0,0 +1,4 @@
+[D-BUS Service]
+Name=org.chromium.Chaps
+Exec=/usr/sbin/chapsd
+User=root
diff --git a/chaps/session_impl.cc b/chaps/session_impl.cc
index 76ee65f..af625c0 100644
--- a/chaps/session_impl.cc
+++ b/chaps/session_impl.cc
@@ -280,6 +280,20 @@ CK_RV SessionImpl::OperationUpdate(OperationType operation,
     LOG(ERROR) << "Operation is not initialized.";
     return CKR_OPERATION_NOT_INITIALIZED;
   }
+  if (context->is_single_) {
+    LOG(ERROR) << "Operation is not incremental.";
+    return CKR_OPERATION_ACTIVE;
+  }
+  context->is_incremental_ = true;
+  return OperationUpdateInternal(operation, data_in, required_out_length, data_out);
+}
+
+CK_RV SessionImpl::OperationUpdateInternal(OperationType operation,
+                                           const string& data_in,
+                                           int* required_out_length,
+                                           string* data_out) {
+  CHECK(operation < kNumOperationTypes);
+  OperationContext* context = &operation_context_[operation];
   if (context->is_cipher_) {
     return CipherUpdate(context, data_in, required_out_length, data_out);
   } else if (context->is_digest_) {
@@ -310,6 +324,19 @@ CK_RV SessionImpl::OperationFinal(OperationType operation,
     LOG(ERROR) << "Operation is not initialized.";
     return CKR_OPERATION_NOT_INITIALIZED;
   }
+  if (context->is_single_) {
+    LOG(ERROR) << "Operation is not incremental.";
+    return CKR_OPERATION_ACTIVE;
+  }
+  context->is_incremental_ = true;
+  return OperationFinalInternal(operation, required_out_length, data_out);
+}
+
+CK_RV SessionImpl::OperationFinalInternal(OperationType operation,
+                                          int* required_out_length,
+                                          string* data_out) {
+  CHECK(operation < kNumOperationTypes);
+  OperationContext* context = &operation_context_[operation];
   context->is_valid_ = false;
   // Complete the operation if it has not already been done.
   if (!context->is_finished_) {
@@ -387,15 +414,24 @@ CK_RV SessionImpl::OperationSinglePart(OperationType operation,
                                        string* data_out) {
   CHECK(operation < kNumOperationTypes);
   OperationContext* context = &operation_context_[operation];
+  if (!context->is_valid_) {
+    LOG(ERROR) << "Operation is not initialized.";
+    return CKR_OPERATION_NOT_INITIALIZED;
+  }
+  if (context->is_incremental_) {
+    LOG(ERROR) << "Operation is incremental.";
+    return CKR_OPERATION_ACTIVE;
+  }
+  context->is_single_ = true;
   CK_RV result = CKR_OK;
   if (!context->is_finished_) {
     string update, final;
     int max = INT_MAX;
-    result = OperationUpdate(operation, data_in, &max, &update);
+    result = OperationUpdateInternal(operation, data_in, &max, &update);
     if (result != CKR_OK)
       return result;
     max = INT_MAX;
-    result = OperationFinal(operation, &max, &final);
+    result = OperationFinalInternal(operation, &max, &final);
     if (result != CKR_OK)
       return result;
     context->data_ = update + final;
@@ -1332,6 +1368,8 @@ void SessionImpl::OperationContext::Clear() {
   is_cipher_ = false;
   is_digest_ = false;
   is_hmac_ = false;
+  is_incremental_ = false;
+  is_single_ = false;
   is_finished_ = false;
   key_ = NULL;
   data_.clear();
diff --git a/chaps/session_impl.h b/chaps/session_impl.h
index 37307ce..7dcb735 100644
--- a/chaps/session_impl.h
+++ b/chaps/session_impl.h
@@ -111,6 +111,8 @@ class SessionImpl : public Session {
     bool is_cipher_;  // Set to true when cipher_context_ is valid.
     bool is_digest_;  // Set to true when digest_context_ is valid.
     bool is_hmac_;  // Set to true when hmac_context_ is valid.
+    bool is_incremental_;  // Set to true when an incremental operation is performed.
+    bool is_single_;  // Set to true when a single operation is performed.
     bool is_finished_;  // Set to true when the operation completes.
     union {
       EVP_CIPHER_CTX cipher_context_;
@@ -133,6 +135,13 @@ class SessionImpl : public Session {
                       CK_OBJECT_CLASS object_class,
                       CK_KEY_TYPE key_type);
   bool IsValidMechanism(OperationType operation, CK_MECHANISM_TYPE mechanism);
+  CK_RV OperationUpdateInternal(OperationType operation,
+                                const std::string& data_in,
+                                int* required_out_length,
+                                std::string* data_out);
+  CK_RV OperationFinalInternal(OperationType operation,
+                               int* required_out_length,
+                               std::string* data_out);
   CK_RV CipherInit(bool is_encrypt,
                    CK_MECHANISM_TYPE mechanism,
                    const std::string& mechanism_parameter,
-- 
1.9.1

