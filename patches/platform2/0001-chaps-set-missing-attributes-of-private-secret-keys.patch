From 24273e74e92d9e2fb65aeb7f540880f1574e0d0e Mon Sep 17 00:00:00 2001
From: David Drysdale <drysdale@google.com>
Date: Fri, 1 May 2015 17:34:06 +0100
Subject: [PATCH] chaps: set missing attributes of private/secret keys

For private/secret keys that are created from external data
with CreateObject:
 - The CKA_KEY_GEN_MECHANISM should be CK_UNAVAILABLE_INFORMATION.
 - The key is not CKA_NEVER_EXTRACTABLE.
 - The key is not CKA_ALWAYS_SENSITIVE.

Noticed by the demo version of the Cryptosense PKCS#11 compliance
test tool.

BUG=None
TEST=Chaps unit tests, pkcs11test project

Change-Id: Ie6a47f0c51f2bea0986f916737d7ba609fb04bd8
---
 chaps/object_policy_key.cc         |  4 ++--
 chaps/object_policy_private_key.cc | 11 +++++++++--
 chaps/object_policy_secret_key.cc  | 11 +++++++++--
 chaps/object_policy_test.cc        | 39 ++++++++++++++++++++++++++++++++++++++
 4 files changed, 59 insertions(+), 6 deletions(-)

diff --git a/chaps/object_policy_key.cc b/chaps/object_policy_key.cc
index e76d615..2d3f03a 100644
--- a/chaps/object_policy_key.cc
+++ b/chaps/object_policy_key.cc
@@ -44,8 +44,8 @@ void ObjectPolicyKey::SetDefaultAttributes() {
   if (!object_->IsAttributePresent(CKA_LOCAL))
     object_->SetAttributeBool(CKA_LOCAL, false);
   if (!object_->IsAttributePresent(CKA_KEY_GEN_MECHANISM))
-    object_->SetAttributeBool(CKA_KEY_GEN_MECHANISM,
-                              CK_UNAVAILABLE_INFORMATION);
+    object_->SetAttributeInt(CKA_KEY_GEN_MECHANISM,
+                             static_cast<int>(CK_UNAVAILABLE_INFORMATION));
 }
 
 }  // namespace chaps
diff --git a/chaps/object_policy_private_key.cc b/chaps/object_policy_private_key.cc
index 1d338ba..159f422 100644
--- a/chaps/object_policy_private_key.cc
+++ b/chaps/object_policy_private_key.cc
@@ -76,10 +76,17 @@ void ObjectPolicyPrivateKey::SetDefaultAttributes() {
   if (!object_->IsAttributePresent(CKA_ALWAYS_AUTHENTICATE))
     object_->SetAttributeBool(CKA_ALWAYS_AUTHENTICATE, false);
   if (object_->GetStage() == kCreate) {
-    if (object_->GetAttributeBool(CKA_SENSITIVE, false))
+    CK_ULONG keygen_mechanism = object_->GetAttributeInt(
+        CKA_KEY_GEN_MECHANISM, static_cast<int>(CK_UNAVAILABLE_INFORMATION));
+    bool keygen_known = (keygen_mechanism != CK_UNAVAILABLE_INFORMATION);
+    if (keygen_known && object_->GetAttributeBool(CKA_SENSITIVE, false))
       object_->SetAttributeBool(CKA_ALWAYS_SENSITIVE, true);
-    if (!object_->GetAttributeBool(CKA_EXTRACTABLE, true))
+    else
+      object_->SetAttributeBool(CKA_ALWAYS_SENSITIVE, false);
+    if (keygen_known && !object_->GetAttributeBool(CKA_EXTRACTABLE, true))
       object_->SetAttributeBool(CKA_NEVER_EXTRACTABLE, true);
+    else
+      object_->SetAttributeBool(CKA_NEVER_EXTRACTABLE, false);
   }
 }
 
diff --git a/chaps/object_policy_secret_key.cc b/chaps/object_policy_secret_key.cc
index a03b343..34b3b35 100644
--- a/chaps/object_policy_secret_key.cc
+++ b/chaps/object_policy_secret_key.cc
@@ -54,10 +54,17 @@ void ObjectPolicySecretKey::SetDefaultAttributes() {
   if (!object_->IsAttributePresent(CKA_WRAP_WITH_TRUSTED))
     object_->SetAttributeBool(CKA_WRAP_WITH_TRUSTED, false);
   if (object_->GetStage() == kCreate) {
-    if (object_->GetAttributeBool(CKA_SENSITIVE, false))
+    CK_ULONG keygen_mechanism = object_->GetAttributeInt(
+        CKA_KEY_GEN_MECHANISM, static_cast<int>(CK_UNAVAILABLE_INFORMATION));
+    bool keygen_known = (keygen_mechanism != CK_UNAVAILABLE_INFORMATION);
+    if (keygen_known && object_->GetAttributeBool(CKA_SENSITIVE, false))
       object_->SetAttributeBool(CKA_ALWAYS_SENSITIVE, true);
-    if (!object_->GetAttributeBool(CKA_EXTRACTABLE, true))
+    else
+      object_->SetAttributeBool(CKA_ALWAYS_SENSITIVE, false);
+    if (keygen_known && !object_->GetAttributeBool(CKA_EXTRACTABLE, true))
       object_->SetAttributeBool(CKA_NEVER_EXTRACTABLE, true);
+    else
+      object_->SetAttributeBool(CKA_NEVER_EXTRACTABLE, false);
   }
 }
 
diff --git a/chaps/object_policy_test.cc b/chaps/object_policy_test.cc
index 0653f23..59f203d 100644
--- a/chaps/object_policy_test.cc
+++ b/chaps/object_policy_test.cc
@@ -145,6 +145,45 @@ TEST_F(TestObjectPolicy, SetDefaultAttributes) {
   EXPECT_FALSE(object_.GetAttributeBool(CKA_DECRYPT, true));
 }
 
+TEST_F(TestObjectPolicy, LatchingAttributes) {
+  for (bool keygen_known: {false, true}) {
+    for (bool extractable: {false, true}) {
+      for (bool sensitive: {false, true}) {
+        ObjectPolicySecretKey policy;
+        policy.Init(&object_);
+        if (keygen_known) {
+          object_.SetAttributeInt(CKA_KEY_GEN_MECHANISM, CKM_DES3_KEY_GEN);
+        } else {
+          object_.RemoveAttribute(CKA_KEY_GEN_MECHANISM);
+        }
+        object_.SetAttributeBool(CKA_EXTRACTABLE, extractable);
+        object_.SetAttributeBool(CKA_SENSITIVE, sensitive);
+        policy.SetDefaultAttributes();
+
+        if (!keygen_known) {
+          // Can't claim the key was never extractable or always sensitive
+          // if we don't know how it was generated.
+          EXPECT_FALSE(object_.GetAttributeBool(CKA_ALWAYS_SENSITIVE, true));
+          EXPECT_FALSE(object_.GetAttributeBool(CKA_NEVER_EXTRACTABLE, true));
+          EXPECT_EQ(static_cast<int>(CK_UNAVAILABLE_INFORMATION),
+                    object_.GetAttributeInt(CKA_KEY_GEN_MECHANISM,
+                                            CKM_DES3_KEY_GEN));
+        } else {
+          EXPECT_EQ(sensitive,
+                    object_.GetAttributeBool(CKA_ALWAYS_SENSITIVE,
+                                             !sensitive));
+          EXPECT_EQ(!extractable,
+                    object_.GetAttributeBool(CKA_NEVER_EXTRACTABLE,
+                                             extractable));
+          EXPECT_EQ(CKM_DES3_KEY_GEN,
+                    object_.GetAttributeInt(CKA_KEY_GEN_MECHANISM,
+                                            CKM_AES_KEY_GEN));
+        }
+      }
+    }
+  }
+}
+
 }  // namespace chaps
 
 int main(int argc, char** argv) {
-- 
1.9.1

